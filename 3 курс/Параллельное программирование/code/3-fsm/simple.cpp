/* ------------------------------------------------------------------------- */
/*  Данный файл является частью комплекта исходных текстов,                  */
/*  иллюстрирующих материал следующего издания:                              */
/*  Федотов И.Е.                                                             */
/*  Модели параллельного программирования. - М.: СОЛОН-ПРЕСС, 2012. - 384 с. */
/*  ISBN 978-5-91359-102-9                                                   */
/*                                                                           */
/*  Как и само издание, прилагаемые к нему исходные тексты предназначены     */
/*  лишь для ознакомления с принципами высокоуровневого построения           */
/*  параллельных программ, а также для проведения дальнейших экспериментов.  */
/*  Использование этого кода в качестве основы для реальных программ         */
/*  допустимо, однако требует доработок и может осуществляться лишь          */
/*  на личный страх и риск разработчика.                                     */
/*  Исходные тексты предоставляются "как есть", без каких бы то ни было      */
/*  явных или неявных гарантий пригодности к практическому применению.       */
/*                                                                           */
/*  Copyright © 2008-2011 Федотов И.Е.                                       */
/* ------------------------------------------------------------------------- */


// #include "../../common/synprintf.hxx"

void get_input(bool &in1, bool &in2)
{
    // ...
}

void put_output(char out)
{
    // ...
}

int main(int argc, char *argv[])
{
    char state = 'A';
    do
    {
        bool in1, in2;
        char out;
        get_input(in1, in2);
        switch (state)
        {
        case 'A':
            out = in1 ? (in2 ? 'c' : 'd') : (in2 ? 'b' : 'a');
            state = (in1 && !in2) ? 'C' : 'B';
            break;
        case 'B':
            out = in1 ? (in2 ? 'b' : 'd') : (in2 ? 'c' : 'a');
            state = !in2 ? 'C' : (in1 ? 'B' : 'A');
            break;
        case 'C':
            out = in1 ? (in2 ? 'c' : 'a') : (in2 ? 'e' : 'd');
            state = in2 ? 'B' : (in1 ? 'A' : 'C');
            break;
        };
        put_output(out);
    } while (state != 'A');
    return 0;
}
