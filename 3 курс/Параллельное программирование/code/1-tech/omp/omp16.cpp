/* ------------------------------------------------------------------------- */
/*  Данный файл является частью комплекта исходных текстов,                  */
/*  иллюстрирующих материал следующего издания:                              */
/*  Федотов И.Е.                                                             */
/*  Модели параллельного программирования. - М.: СОЛОН-ПРЕСС, 2012. - 384 с. */
/*  ISBN 978-5-91359-102-9                                                   */
/*                                                                           */
/*  Как и само издание, прилагаемые к нему исходные тексты предназначены     */
/*  лишь для ознакомления с принципами высокоуровневого построения           */
/*  параллельных программ, а также для проведения дальнейших экспериментов.  */
/*  Использование этого кода в качестве основы для реальных программ         */
/*  допустимо, однако требует доработок и может осуществляться лишь          */
/*  на личный страх и риск разработчика.                                     */
/*  Исходные тексты предоставляются "как есть", без каких бы то ни было      */
/*  явных или неявных гарантий пригодности к практическому применению.       */
/*                                                                           */
/*  Copyright © 2008-2011 Федотов И.Е.                                       */
/* ------------------------------------------------------------------------- */


#include <omp.h>
#include "../../common/synprintf.hxx"
using namespace z;

void process(int i)
{
    // ...
    synprintf(stdout, "Iter %d\n", i);
}

int main(int argc, char *argv[])
{
    int n = 100;

    // если уже в параллельном регионе
    // и вложенный параллелизм запрещен
    if (omp_in_parallel() && !omp_get_nested())
    {
        // выполним цикл последовательно
        for (int i = 0; i < n; ++i)
            process(i);
    }
    else
    {
        // иначе получим количество процессоров
        int num = omp_get_num_procs();
        // зададим соответствующее количество потоков
        omp_set_num_threads(num);
        // выполним цикл параллельно
        #pragma omp parallel
        {
            // получим реальное количество потоков
            #pragma omp single
            num = omp_get_num_threads();
            // и номер нашего потока среди них
            int id = omp_get_thread_num();
            // выполним нашу часть итераций
            // в соответствии с циклическим распределением
            for (int i = id; i < n; i += num)
                process(i);
        }
    }
    return 0;
}
