/* ------------------------------------------------------------------------- */
/*  Данный файл является частью комплекта исходных текстов,                  */
/*  иллюстрирующих материал следующего издания:                              */
/*  Федотов И.Е.                                                             */
/*  Модели параллельного программирования. - М.: СОЛОН-ПРЕСС, 2012. - 384 с. */
/*  ISBN 978-5-91359-102-9                                                   */
/*                                                                           */
/*  Как и само издание, прилагаемые к нему исходные тексты предназначены     */
/*  лишь для ознакомления с принципами высокоуровневого построения           */
/*  параллельных программ, а также для проведения дальнейших экспериментов.  */
/*  Использование этого кода в качестве основы для реальных программ         */
/*  допустимо, однако требует доработок и может осуществляться лишь          */
/*  на личный страх и риск разработчика.                                     */
/*  Исходные тексты предоставляются "как есть", без каких бы то ни было      */
/*  явных или неявных гарантий пригодности к практическому применению.       */
/*                                                                           */
/*  Copyright © 2008-2011 Федотов И.Е.                                       */
/* ------------------------------------------------------------------------- */


#ifdef _OPENMP
#include <omp.h>
#endif //_OPENMP

#include <cmath>
#include "../../common/synprintf.hxx"
using namespace z;

double func(double x)
{
    return 4.0 / (1.0 + x * x);
}

int main(int argc, char *argv[])
{
    // левая и правая границы области интегрирования
    double a = 0.0, b = 1.0;
    // точность
    double eps = 0.0001;
    // количество интервалов - начальное разбиение
    int n = 10;
    // количество выполненных итераций
    int iter = 0;
    // текущий и предыдущий результаты
    double sum = 0.0, sumpre = 0.0;
    // критерий выполнения итераций
    bool perform = true;

    #pragma omp parallel
    while (perform)
    {
        // шаг разбиения
        double h = (b - a) / n;
        // вычисление интеграла для заданного разбиения
        #pragma omp single
        {
            sumpre = sum;
            sum = 0.0;
        };
        #pragma omp for reduction(+: sum)
        for (int i = 0; i < n; ++i)
        {
            // середина интервала
            double x = a + h * (i + 0.5);
            // значение интегрируемой функции
            double f = func(x);
            // площадь прямоугольника
            sum += f * h;
        };
        #pragma omp single
        {
            // удвоение количества интервалов
            n <<= 1;
            // если итерация была первая, продолжаем
            perform = iter++ == 0 || fabs(sum - sumpre) > eps;
        };
    };

    synprintf(stdout, "Result: %.16f, iterations: %d\n", sum, iter);
    return 0;
}
