/* ------------------------------------------------------------------------- */
/*  Данный файл является частью комплекта исходных текстов,                  */
/*  иллюстрирующих материал следующего издания:                              */
/*  Федотов И.Е.                                                             */
/*  Модели параллельного программирования. - М.: СОЛОН-ПРЕСС, 2012. - 384 с. */
/*  ISBN 978-5-91359-102-9                                                   */
/*                                                                           */
/*  Как и само издание, прилагаемые к нему исходные тексты предназначены     */
/*  лишь для ознакомления с принципами высокоуровневого построения           */
/*  параллельных программ, а также для проведения дальнейших экспериментов.  */
/*  Использование этого кода в качестве основы для реальных программ         */
/*  допустимо, однако требует доработок и может осуществляться лишь          */
/*  на личный страх и риск разработчика.                                     */
/*  Исходные тексты предоставляются "как есть", без каких бы то ни было      */
/*  явных или неявных гарантий пригодности к практическому применению.       */
/*                                                                           */
/*  Copyright © 2008-2011 Федотов И.Е.                                       */
/* ------------------------------------------------------------------------- */


#include <omp.h>
#include <map>
#include <list>
#include "../../common/synprintf.hxx"
using namespace z;

using namespace std;


int main(int argc, char *argv[])
{
    typedef int some_type;
    list<some_type> queue(omp_get_max_threads(), 0);
    map<int, some_type> store;

    omp_lock_t lockstore, lockqueue;
    omp_init_lock(&lockstore);
    omp_init_lock(&lockqueue);

    // ...

    #pragma omp parallel
    {
        // ...

        omp_set_lock(&lockstore);

        // формирование уникального в хранилище идентификатора
        int id = store.size();

        omp_set_lock(&lockqueue);

        // помещение в хранилище головного элемента очереди
        store[id] = queue.front();

        omp_unset_lock(&lockstore);

        // извлечение головного элемента очереди
        queue.pop_front();

        omp_unset_lock(&lockqueue);

        // ...
    }

    // ...

    omp_destroy_lock(&lockstore);
    omp_destroy_lock(&lockqueue);

    return 0;
}
