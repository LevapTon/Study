/* ------------------------------------------------------------------------- */
/*  Данный файл является частью комплекта исходных текстов,                  */
/*  иллюстрирующих материал следующего издания:                              */
/*  Федотов И.Е.                                                             */
/*  Модели параллельного программирования. - М.: СОЛОН-ПРЕСС, 2012. - 384 с. */
/*  ISBN 978-5-91359-102-9                                                   */
/*                                                                           */
/*  Как и само издание, прилагаемые к нему исходные тексты предназначены     */
/*  лишь для ознакомления с принципами высокоуровневого построения           */
/*  параллельных программ, а также для проведения дальнейших экспериментов.  */
/*  Использование этого кода в качестве основы для реальных программ         */
/*  допустимо, однако требует доработок и может осуществляться лишь          */
/*  на личный страх и риск разработчика.                                     */
/*  Исходные тексты предоставляются "как есть", без каких бы то ни было      */
/*  явных или неявных гарантий пригодности к практическому применению.       */
/*                                                                           */
/*  Copyright © 2008-2011 Федотов И.Е.                                       */
/* ------------------------------------------------------------------------- */


#include <cstdio>

#include "../../common/zmatrix.hxx"

using namespace std;
using namespace z;

enum { NUM_ITER = 20 };

int main(int argc, char *argv[])
{
    // решение интегрального уравнения u(x) - int(0, 1, x * y * u(y), dy) = 2/3 * x
    // должно быть u(x) = x, x in [0, 1)
    const int n = 5000;

    // матрица
    matrix_type<double> a(n, n);
    for (int i = 0; i < a.vsize(); ++i)
        for (int j = 0; j < a.hsize(); ++j)
            a(i, j) = ((i + 0.5) / n) * ((j + 0.5) / n) / n;

    // вектор свободных коэффициентов
    vector_type<double> f(n);
    for (int i = 0; i < f.vsize(); ++i)
        f(i) = 2.0 / 3.0 * (i + 0.5) / n;

    // вектор текущего приближения
    vector_type<double> u = f;
    // выполнение нескольких простых итераций
    for (int i = 0; i < NUM_ITER; ++i)
        u = a * u + f;

    // вывод результатов
    for (int i = 0; i < u.vsize(); ++i)
        fprintf(stdout, "%f\n", u(i));
    return 0;
}
