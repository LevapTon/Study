/* ------------------------------------------------------------------------- */
/*  Данный файл является частью комплекта исходных текстов,                  */
/*  иллюстрирующих материал следующего издания:                              */
/*  Федотов И.Е.                                                             */
/*  Модели параллельного программирования. - М.: СОЛОН-ПРЕСС, 2012. - 384 с. */
/*  ISBN 978-5-91359-102-9                                                   */
/*                                                                           */
/*  Как и само издание, прилагаемые к нему исходные тексты предназначены     */
/*  лишь для ознакомления с принципами высокоуровневого построения           */
/*  параллельных программ, а также для проведения дальнейших экспериментов.  */
/*  Использование этого кода в качестве основы для реальных программ         */
/*  допустимо, однако требует доработок и может осуществляться лишь          */
/*  на личный страх и риск разработчика.                                     */
/*  Исходные тексты предоставляются "как есть", без каких бы то ни было      */
/*  явных или неявных гарантий пригодности к практическому применению.       */
/*                                                                           */
/*  Copyright © 2008-2011 Федотов И.Е.                                       */
/* ------------------------------------------------------------------------- */


#include <windows.h>
#include <cstdio>

using namespace std;

enum { NUM_ITER = 1000000, NUM_THREADS = 4 };

// структура параметров потока
struct thr_param
{
    int begin;
    int end;
    double result;
};

// функция потока
DWORD WINAPI thr_proc(LPVOID param)
{
    thr_param &p = *static_cast<thr_param *>(param);
    for (int i = p.begin; i < p.end; ++i)
        p.result += ((i & 1) ? - 1.0 : 1.0) / ((i << 1) | 1);
    return 0;
}

int main(int argc, char *argv[])
{
    // заполнение параметров для каждого потока
    thr_param param[NUM_THREADS];
    for (int i = 0; i < NUM_THREADS; ++i)
    {
        param[i].begin = i * (NUM_ITER / NUM_THREADS);
        param[i].end = (i + 1) * (NUM_ITER / NUM_THREADS);
        param[i].result = 0.0;
    };
    // создание потоков
    HANDLE hdl[NUM_THREADS - 1];
    DWORD dwId[NUM_THREADS - 1];
    for (int i = 0; i < NUM_THREADS - 1; ++i)
        hdl[i] = ::CreateThread(
            NULL, 0,
            thr_proc, &param[i + 1],
            0, &dwId[i]);
    // выполнение в главном потоке
    thr_proc(&param[0]);
    // ожидание завершения работы потоков
    ::WaitForMultipleObjects(NUM_THREADS - 1, hdl, TRUE, INFINITE);
    // освобождение ресурсов
    for (int i = 0; i < NUM_THREADS - 1; ++i)
        ::CloseHandle(hdl[i]);
    // суммирование результатов воедино
    double sum = 0.0;
    for (int i = 0; i < NUM_THREADS; ++i)
        sum += param[i].result;
    fprintf(stdout, "%.16f\n", sum * 4.0);
    return 0;
}
