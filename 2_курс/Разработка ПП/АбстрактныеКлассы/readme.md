# Вариант 14  
  
## Задание 1  

**Замечания**  
1) Полную структуру классов и их взаимосвязь продумать самостоятельно;  
2) Для абстрактного класса определить, какие методы должны быть абстрактными, а какие обычными.  

**Задачи**  
1. Создать абстрактный класс *Vehicle* (транспортное средство) с функциями, позволяющими вывести на экран информацию о транспортных средствах, а также определить соответствие записи критерию поиска;
2. В абстрактном классе *Vehicle* реализовать метод *CompareTo* так, чтобы можно было отсортировать базу данных по цене;
3. Создать производные классы: *Plane* (авиакомпания, количество пассажиров, цена, год выпуска), *Саг* (цена, год выпуска) и *Ship* ( порт приписки, количество пассажиров, цена, год выпуска);
4. Создать базу (обобщенный список) из n транспортный средств, вывести полную информацию из базы на экран, отсортировав базу данных по году выпуска, а также организовать поиск в базе транспортных средств по заданной вместимости пассажиров. 
 
---  

## Задание 2  
Реализовать класс хеш-таблиц *Hash()* для хранения элементов описанной в задании 1 иерархии классов.  
```cs
class Hash: IEnumerable
 {
    protected ArrayList keys;
    protected List<MyClass> values;
    …
 }
```  
Для этого:
1. **Реализовать конструкторы:**  
*public Hash()* - предназначен для создания пустой коллекции.  
*public Hash (int capacity)* - создает пустую коллекцию с начальной емкостью, заданной параметром capacity.  
*public Hash ( Hash h)* - служит для создания коллекции, которая инициализируется элементами и емкостью коллекции, заданной параметром h.
2. **Реализовать:**  
a) свойство *Count*, позволяющее получить количество элементов в коллекции;  
b) индексатор;  
c) методы для добавления одного *Add(object key, MyClass t)* или нескольких элементов *AddRange(Hash h)* в коллекцию;  
d) методы для удаления одного *Remove(object key)* или нескольких элементов из коллекции *RemoveAll(Hash h)*;  
e) метод для поиска элемента по значению *Find( MyClass value)*;  
f) метод для клонирования коллекции;  
g) метод для поверхностного копирования;  
h) очистку коллекции;  
i) также реализовать интерфейсы *IEnumerable* и *Ienumerator* (реализовать итератор).  

**В методе main():**  
a) Заполнить созданную коллекцию объектами. Используя меню, реализовать в программе добавление и удаление объектов коллекции.  
b) Разработать и реализовать три запроса (количество элементов определенного вида, печать элементов определенного вида и т.п.).  
c) Выполнить перебор элементов коллекции с помощью метода foreach.  
d) Выполнить клонирование коллекции.  
e) Выполнить поиск заданного элемента в коллекции.  

---  

## Задание 3  
1. Определить класс *MyNewCollection*, производный от класса *Hash*, который с помощью событий извещает об изменениях в коллекции. Коллекция изменяется:
- при удалении/добавлении элементов
- при изменении одной из входящих в коллекцию ссылок, например, когда одной из ссылок присваивается новое значение.  
В этом случае в соответствующих методах или свойствах класса бросаются события. 
2. В новую версию класса *MyNewCollection* добавить  
- открытое автореализуемое свойство типа string с названием коллекции;  
- метод *bool Remove (object key)* для удаления элемента с ключом key ; если в списке нет элемента с таким ключом, метод возвращает значение false;  
- перегрузить индексатор, добавив выбрасывание события при изменении данных.
3. Для событий, извещающих об изменениях в коллекции, определяется свой делегат *CollectionHandler* с сигнатурой:
~~~cs
void CollectionHandler (object source, CollectionHandlerEventArgs args);
~~~
4. Для передачи информации о событии определить класс *CollectionHandlerEventArgs*, производный от класса *System.EventArgs*, который содержит:  
- открытое автореализуемое свойство типа string с названием коллекции, в которой произошло событие;  
- открытое автореализуемое свойство типа string с информацией о типе изменений в коллекции;  
- открытое автореализуемое свойство для ссылки на объект, с которым связаны изменения;  
- конструкторы для инициализации класса;  
- перегруженную версию метода *string ToString()* для формирования строки с информацией обо всех полях класса. 
5. В класс *MyNewCollection* добавить два события типа *CollectionHandler*:  
- *CollectionCountChanged*, которое происходит при добавлении нового элемента в коллекцию или при удалении элемента из коллекции; через объект *CollectionHandlerEventArgs* cобытие передает имя коллекции, строку с информацией о том, что в коллекцию был добавлен новый элемент или из нее был удален элемент, ссылку на добавленный или удаленный элемент;  
- *CollectionReferenceChanged*, которое происходит, когда одной из ссылок, входящих в коллекцию, присваивается новое значение; через объект *CollectionHandlerEventArgs* событие передает имя коллекции, строку с информацией о том, что был заменен элемент в коллекции, и ссылку на новый элемент. 
6. Событие *CollectionCountChanged* бросают следующие методы класса *MyNewCollection*:  
- *AddDefaults()*;  
- *Add (object[] )*;  
- *Remove (int index)*. 
7. Событие *CollectionReferenceChanged* бросает метод set индексатора, определенного в классе *MyNewCollection*. 
8. Информация об изменениях коллекции записывается в класс *Journal*, который хранит информацию в списке объектов типа *JournalEntry*. Каждый объект типа *JournalEntry* содержит информацию об отдельном изменении, которое произошло в коллекции. *JournalEntry* содержит:  
- открытое автореализуемое свойство типа string с названием коллекции, в которой произошло событие;  
- открытое автореализуемое свойство типа string с информацией о типе изменений в коллекции;  
- открытое автореализуемое свойство типа string c данными объекта, с которым связаны изменения в коллекции;  
- конструктор для инициализации полей класса;  
- перегруженную версию метода string *ToString()*.  
- всех элементах массива. 
9. Написать демонстрационную программу, в которой:  
- создать две коллекции *MyNewCollection*.  
- Создать два объекта типа *Journal*, один объект *Journal* подписать на события *CollectionCountChanged* и *CollectionReferenceChanged* из первой коллекции, другой объект *Journal* подписать на события *CollectionReferenceChanged* из обеих коллекций. 
10. Внести изменения в коллекции *MyNewCollection*  
- добавить элементы в коллекции;  
- удалить некоторые элементы из коллекций;  
- присвоить некоторым элементам коллекций новые значения
11. Вывести данные обоих объектов Journal.
