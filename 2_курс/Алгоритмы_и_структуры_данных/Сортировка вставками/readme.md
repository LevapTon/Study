# **Сортировка вставками**  
В ходе данной лаболаторной работы необходимо разработать алгоритм, проводящий сортировку списка в порядке не уменьшения элементов списка, а также проверить его на возможность работы с большим объемом входных данных.  

---  

## **Фрагмент алгоритма**
```py
def insert_sort(lst):
    for i in range(1, (len(lst))):
        tmp = lst[i]
        while (i > 0) and (tmp <= lst[i - 1]):
            lst[i] = lst[i - 1] 
            i -= 1
        else:
            lst[i] = tmp
    return(lst)
```  
Выше представлена функция "*insert_sort*", на вход которой поступает не отсортированный список элементов. Функция представленна в виде двух вложенных циклов, а именно: внешний цикл "*for*" и внутренний цикл "*while*".  
Так как в данном виде сортировки i-ый элемент сравнивается с предыдущими, то нет необходимости начинать цикл "for" с нулевого элемента. Данный цикл перебирает номера элементов массива.  
После объявления внешнего цикла в переменную "tmp" записывается значение текущего элемента списка.  
В цикле "while" обозначены два условия:
- номер элемента должен быть строго больше нуля;
- текущий элемент должен быть не строго меньше предыдущего.  

В случае не выполнения условий цикла текущий элемент будет поставлен в то место, на котором нужный нам элемент будет соответствовать условиям поставленной задачи.  
В теле цикла "While" на место взятого элемента ставится предыдущий, после чего индекс "i" уменьшается на единицу.

---

## **Проверка алгоритма на работу с большим объемом данных**  
После разработки алгоритма необходимо проверить увеличение времени работы программы в зависимости от увеличения количества входных данных.  
Результаты проведенной работы представлены в таблице ниже.  
|Количество элементов (ед.)  |Время выполнения программы (с.)|
|----------|-----------|
|100       |0,015      |
|500       |0,062      |
|1000      |0,156      |
|5000      |1,641      |
|10000     |6,656      |
|20000     |25,970     |  

С увелечнием на порядок количества входных элементов время на выполнение программмы значительно возрастает, следовательно взятый алгоритм не подходит для обработки больших массивов данных, хотя и имеет преимущество в виде затрачиваемой памяти.